"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxPluginImpl = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const questions_1 = require("./utils/questions");
const utils_1 = require("./utils/utils");
const constants_1 = require("./utils/constants");
const error_1 = require("./error");
const util = tslib_1.__importStar(require("util"));
const progress_helper_1 = require("./utils/progress-helper");
const tools_1 = require("../../../common/tools");
const folder_1 = require("../../../folder");
const constants_2 = require("../appstudio/constants");
const axios_1 = tslib_1.__importDefault(require("axios"));
const spoClient_1 = require("./spoClient");
const addFeature_1 = require("../../solution/fx-solution/v3/addFeature");
const utils4v2_1 = require("../utils4v2");
const localizeUtils_1 = require("../../../common/localizeUtils");
const yoChecker_1 = require("./depsChecker/yoChecker");
const generatorChecker_1 = require("./depsChecker/generatorChecker");
const cpUtils_1 = require("../../solution/fx-solution/utils/depsChecker/cpUtils");
class SPFxPluginImpl {
    async postScaffold(ctx) {
        var _a, _b, _c, _d, _e, _f;
        const progressHandler = await progress_helper_1.ProgressHelper.startScaffoldProgressHandler(ctx.ui);
        try {
            const webpartName = ctx.answers[questions_1.SPFXQuestionNames.webpart_name];
            const componentName = utils_1.Utils.normalizeComponentName(webpartName);
            const componentNameCamelCase = lodash_1.default.camelCase(componentName);
            const templateFolder = path.join(folder_1.getTemplatesFolder(), "plugins", "resource", "spfx");
            const outputFolderPath = `${ctx.root}/SPFx`;
            const replaceMap = new Map();
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.ScaffoldProgressMessage.DependencyCheck));
            const yoChecker = new yoChecker_1.YoChecker(ctx.logProvider);
            const spGeneratorChecker = new generatorChecker_1.GeneratorChecker(ctx.logProvider);
            const yoInstalled = await yoChecker.isInstalled();
            const generatorInstalled = await spGeneratorChecker.isInstalled();
            if (!yoInstalled || !generatorInstalled) {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.ScaffoldProgressMessage.DependencyInstall));
                if (tools_1.isYoCheckerEnabled()) {
                    const yoRes = await yoChecker.ensureDependency(ctx);
                    if (yoRes.isErr()) {
                        throw error_1.DependencyInstallError("yo");
                    }
                }
                if (tools_1.isGeneratorCheckerEnabled()) {
                    const spGeneratorRes = await spGeneratorChecker.ensureDependency(ctx);
                    if (spGeneratorRes.isErr()) {
                        throw error_1.DependencyInstallError("sharepoint generator");
                    }
                }
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.ScaffoldProgressMessage.ScaffoldProject));
            const framework = ctx.answers[questions_1.SPFXQuestionNames.framework_type];
            const solutionName = (_a = ctx.projectSettings) === null || _a === void 0 ? void 0 : _a.appName;
            if (((_b = ctx.answers) === null || _b === void 0 ? void 0 : _b.platform) === teamsfx_api_1.Platform.VSCode) {
                ctx.logProvider.outputChannel.show();
            }
            const yoEnv = process.env;
            yoEnv.PATH = tools_1.isYoCheckerEnabled()
                ? `${await yoChecker.getBinFolder()}${path.delimiter}${(_c = process.env.PATH) !== null && _c !== void 0 ? _c : ""}`
                : process.env.PATH;
            await cpUtils_1.cpUtils.executeCommand(ctx.root, ctx.logProvider, {
                timeout: 2 * 60 * 1000,
                env: yoEnv,
            }, "yo", "@microsoft/sharepoint", "--skip-install", "true", "--component-type", "webpart", "--component-name", webpartName, "--framework", framework, "--solution-name", solutionName, "--environment", "spo", "--skip-feature-deployment", "true", "--is-domain-isolated", "false");
            const currentPath = path.join(ctx.root, solutionName);
            const newPath = path.join(ctx.root, "SPFx");
            await fs.rename(currentPath, newPath);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.ScaffoldProgressMessage.UpdateManifest));
            const manifestPath = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.manifest.json`;
            const manifest = await fs.readFile(manifestPath, "utf8");
            let manifestString = manifest.toString();
            manifestString = manifestString.replace(`"supportedHosts": ["SharePointWebPart"]`, `"supportedHosts": ["SharePointWebPart", "TeamsPersonalApp", "TeamsTab"]`);
            await fs.writeFile(manifestPath, manifestString);
            const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
            const manifestJson = JSON.parse(manifestString.replace(matchHashComment, "").trim());
            const componentId = manifestJson.id;
            replaceMap.set(constants_1.PlaceHolders.componentId, componentId);
            replaceMap.set(constants_1.PlaceHolders.componentNameUnescaped, webpartName);
            // remove dataVersion() function, related issue: https://github.com/SharePoint/sp-dev-docs/issues/6469
            const webpartFile = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.ts`;
            const codeFile = await fs.readFile(webpartFile, "utf8");
            let codeString = codeFile.toString();
            codeString = codeString.replace(`  protected get dataVersion(): Version {\r\n    return Version.parse('1.0');\r\n  }\r\n\r\n`, ``);
            codeString = codeString.replace(`import { Version } from '@microsoft/sp-core-library';\r\n`, ``);
            await fs.writeFile(webpartFile, codeString);
            // remove .vscode
            const debugPath = `${newPath}/.vscode`;
            await fs.remove(debugPath);
            // update readme
            await fs.copyFile(path.resolve(templateFolder, "./solution/README.md"), `${outputFolderPath}/README.md`);
            const appDirectory = await tools_1.getAppDirectory(ctx.root);
            await utils_1.Utils.configure(path.join(appDirectory, constants_2.MANIFEST_TEMPLATE_CONSOLIDATE), replaceMap);
            const appManifestProvider = new addFeature_1.DefaultManifestProvider();
            const capabilitiesToAddManifest = [];
            const remoteStaticSnippet = {
                entityId: componentId,
                name: webpartName,
                contentUrl: util.format(constants_1.ManifestTemplate.REMOTE_CONTENT_URL, componentId, componentId),
                websiteUrl: constants_1.ManifestTemplate.WEBSITE_URL,
                scopes: ["personal"],
            };
            const remoteConfigurableSnippet = {
                configurationUrl: util.format(constants_1.ManifestTemplate.REMOTE_CONFIGURATION_URL, componentId, componentId),
                canUpdateConfiguration: true,
                scopes: ["team"],
            };
            capabilitiesToAddManifest.push({
                name: "staticTab",
                snippet: remoteStaticSnippet,
            }, {
                name: "configurableTab",
                snippet: remoteConfigurableSnippet,
            });
            const contextWithInputs = utils4v2_1.convert2Context(ctx, true);
            for (const capability of capabilitiesToAddManifest) {
                const addCapRes = await appManifestProvider.updateCapability(contextWithInputs.context, contextWithInputs.inputs, capability);
                if (addCapRes.isErr())
                    return teamsfx_api_1.err(addCapRes.error);
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            if (error.name === "DependencyInstallFailed") {
                const globalYoVersion = utils_1.Utils.getPackageVersion("yo");
                const globalGenVersion = utils_1.Utils.getPackageVersion("@microsoft/generator-sharepoint");
                const yoInfo = yoChecker_1.YoChecker.getDependencyInfo();
                const genInfo = generatorChecker_1.GeneratorChecker.getDependencyInfo();
                const yoMessage = globalYoVersion === undefined
                    ? "    yo not installed"
                    : `    globally installed yo@${globalYoVersion}`;
                const generatorMessage = globalGenVersion === undefined
                    ? "    @microsoft/generator-sharepoint not installed"
                    : `    globally installed @microsoft/generator-sharepoint@${globalYoVersion}`;
                (_d = ctx.logProvider) === null || _d === void 0 ? void 0 : _d.error(`We've encountered some issues when trying to install prerequisites under HOME/.fx folder.  Learn how to remediate by going to this link(aka.ms/teamsfx-spfx-help) and following the steps applicable to your system: \n ${yoMessage} \n ${generatorMessage}`);
                (_e = ctx.logProvider) === null || _e === void 0 ? void 0 : _e.error(`Teams Toolkit recommends using ${yoInfo.displayName} ${genInfo.displayName}`);
            }
            if (error.message &&
                error.message.includes("'yo' is not recognized as an internal or external command")) {
                (_f = ctx.logProvider) === null || _f === void 0 ? void 0 : _f.error("NPM v6.x with Node.js v12.13.0+ (Erbium) or Node.js v14.15.0+ (Fermium) is recommended for spfx scaffolding and later development. You can use correct version and try again.");
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
            return teamsfx_api_1.err(error_1.ScaffoldError(error));
        }
    }
    async buildSPPackage(ctx) {
        var _a, _b, _c, _d;
        const progressHandler = await progress_helper_1.ProgressHelper.startPreDeployProgressHandler(ctx.ui);
        if (((_a = ctx.answers) === null || _a === void 0 ? void 0 : _a.platform) === teamsfx_api_1.Platform.VSCode) {
            ctx.logProvider.outputChannel.show();
        }
        try {
            const workspacePath = `${ctx.root}/SPFx`;
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.NpmInstall));
            await utils_1.Utils.execute(`npm install`, "SPFx", workspacePath, ctx.logProvider, true);
            const gulpCommand = await SPFxPluginImpl.findGulpCommand(workspacePath);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpBundle));
            await utils_1.Utils.execute(`${gulpCommand} bundle --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.PreDeployProgressMessage.GulpPackage));
            await utils_1.Utils.execute(`${gulpCommand} package-solution --ship --no-color`, "SPFx", workspacePath, ctx.logProvider, true);
            await progress_helper_1.ProgressHelper.endPreDeployProgress(true);
            const sharepointPackage = await this.getPackage(ctx.root);
            if (!(await fs.pathExists(sharepointPackage))) {
                throw error_1.NoSPPackageError(sharepointPackage);
            }
            const dir = path.normalize(path.parse(sharepointPackage).dir);
            if (((_b = ctx.answers) === null || _b === void 0 ? void 0 : _b.platform) === teamsfx_api_1.Platform.CLI) {
                const guidance = [
                    {
                        content: "Success: SharePoint package successfully built at ",
                        color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                    },
                    { content: dir, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
                ];
                (_c = ctx.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", guidance, false);
            }
            else {
                const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.buildNotice", dir);
                (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", guidance, false, "OK");
            }
            return teamsfx_api_1.ok(undefined);
        }
        catch (error) {
            await progress_helper_1.ProgressHelper.endPreDeployProgress(false);
            return teamsfx_api_1.err(error_1.BuildSPPackageError(error));
        }
    }
    async preDeploy(ctx) {
        return this.buildSPPackage(ctx);
    }
    async deploy(ctx) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const progressHandler = await progress_helper_1.ProgressHelper.startDeployProgressHandler(ctx.ui);
        let success = false;
        try {
            const tenant = await this.getTenant(ctx);
            if (tenant.isErr()) {
                return tenant;
            }
            spoClient_1.SPOClient.setBaseUrl(tenant.value);
            const spoToken = await tools_1.getSPFxToken(ctx.m365TokenProvider);
            if (!spoToken) {
                return teamsfx_api_1.err(error_1.GetSPOTokenFailedError());
            }
            let appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
            if (appCatalogSite) {
                spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
            }
            else {
                const res = await ((_a = ctx.ui) === null || _a === void 0 ? void 0 : _a.showMessage("warn", localizeUtils_1.getLocalizedString("plugins.spfx.createAppCatalogNotice", tenant.value), true, "OK", constants_1.Constants.READ_MORE));
                const confirm = (res === null || res === void 0 ? void 0 : res.isOk()) ? res.value : undefined;
                switch (confirm) {
                    case "OK":
                        try {
                            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.CreateSPAppCatalog));
                            await spoClient_1.SPOClient.createAppCatalog(spoToken);
                        }
                        catch (e) {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(e));
                        }
                        let retry = 0;
                        appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                        while (appCatalogSite == null && retry < constants_1.Constants.APP_CATALOG_MAX_TIMES) {
                            (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.warning(`No tenant app catalog found, retry: ${retry}`);
                            await utils_1.sleep(constants_1.Constants.APP_CATALOG_REFRESH_TIME);
                            appCatalogSite = await spoClient_1.SPOClient.getAppCatalogSite(spoToken);
                            retry += 1;
                        }
                        if (appCatalogSite) {
                            spoClient_1.SPOClient.setBaseUrl(appCatalogSite);
                            (_c = ctx.logProvider) === null || _c === void 0 ? void 0 : _c.info(`Sharepoint tenant app catalog ${appCatalogSite} created, wait for a few minutes to be active.`);
                            await utils_1.sleep(constants_1.Constants.APP_CATALOG_ACTIVE_TIME);
                        }
                        else {
                            return teamsfx_api_1.err(error_1.CreateAppCatalogFailedError(new Error(localizeUtils_1.getLocalizedString("plugins.spfx,cannotGetAppcatalog"))));
                        }
                        break;
                    case constants_1.Constants.READ_MORE:
                        (_d = ctx.ui) === null || _d === void 0 ? void 0 : _d.openUrl(constants_1.Constants.CREATE_APP_CATALOG_GUIDE);
                        return teamsfx_api_1.ok(teamsfx_api_1.UserCancelError);
                    default:
                        return teamsfx_api_1.ok(undefined);
                }
            }
            const appPackage = await this.getPackage(ctx.root);
            if (!(await fs.pathExists(appPackage))) {
                return teamsfx_api_1.err(error_1.NoSPPackageError(appPackage));
            }
            const fileName = path.parse(appPackage).base;
            const bytes = await fs.readFile(appPackage);
            try {
                await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next(constants_1.DeployProgressMessage.UploadAndDeploy));
                await spoClient_1.SPOClient.uploadAppPackage(spoToken, fileName, bytes);
            }
            catch (e) {
                if (((_e = e.response) === null || _e === void 0 ? void 0 : _e.status) === 403) {
                    (_f = ctx.ui) === null || _f === void 0 ? void 0 : _f.showMessage("error", localizeUtils_1.getLocalizedString("plugins.spfx.deployFailedNotice", appCatalogSite), false, "OK");
                    return teamsfx_api_1.err(error_1.InsufficientPermissionError(appCatalogSite));
                }
                else {
                    return teamsfx_api_1.err(error_1.UploadAppPackageFailedError(e));
                }
            }
            const appID = await this.getAppID(ctx.root);
            await spoClient_1.SPOClient.deployAppPackage(spoToken, appID);
            const guidance = localizeUtils_1.getLocalizedString("plugins.spfx.deployNotice", appPackage, appCatalogSite, appCatalogSite);
            if (((_g = ctx.answers) === null || _g === void 0 ? void 0 : _g.platform) === teamsfx_api_1.Platform.CLI) {
                (_h = ctx.ui) === null || _h === void 0 ? void 0 : _h.showMessage("info", guidance, false);
            }
            else {
                (_j = ctx.ui) === null || _j === void 0 ? void 0 : _j.showMessage("info", guidance, false, "OK");
            }
            success = true;
            return teamsfx_api_1.ok(undefined);
        }
        finally {
            await progress_helper_1.ProgressHelper.endDeployProgress(success);
        }
    }
    async getTenant(ctx) {
        var _a, _b;
        const graphTokenRes = await ((_a = ctx.m365TokenProvider) === null || _a === void 0 ? void 0 : _a.getAccessToken({ scopes: tools_1.GraphScopes }));
        const graphToken = (graphTokenRes === null || graphTokenRes === void 0 ? void 0 : graphTokenRes.isOk()) ? graphTokenRes.value : undefined;
        if (!graphToken) {
            return teamsfx_api_1.err(error_1.GetGraphTokenFailedError());
        }
        const graphTokenJsonRes = await ((_b = ctx.m365TokenProvider) === null || _b === void 0 ? void 0 : _b.getJsonObject({ scopes: tools_1.GraphScopes }));
        const tokenJson = (graphTokenJsonRes === null || graphTokenJsonRes === void 0 ? void 0 : graphTokenJsonRes.isOk()) ? graphTokenJsonRes.value : undefined;
        const username = tokenJson.unique_name;
        const instance = axios_1.default.create({
            baseURL: "https://graph.microsoft.com/v1.0",
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${graphToken}`;
        let tenant = "";
        try {
            const res = await instance.get("/sites/root?$select=webUrl");
            if (res && res.data && res.data.webUrl) {
                tenant = res.data.webUrl;
            }
            else {
                return teamsfx_api_1.err(error_1.GetTenantFailedError(username));
            }
        }
        catch (e) {
            return teamsfx_api_1.err(error_1.GetTenantFailedError(username, e));
        }
        return teamsfx_api_1.ok(tenant);
    }
    async getPackage(root) {
        const solutionConfig = await fs.readJson(`${root}/SPFx/config/package-solution.json`);
        const sharepointPackage = `${root}/SPFx/sharepoint/${solutionConfig.paths.zippedPackage}`;
        return sharepointPackage;
    }
    async getAppID(root) {
        const solutionConfig = await fs.readJson(`${root}/SPFx/config/package-solution.json`);
        const appID = solutionConfig["solution"]["id"];
        return appID;
    }
    static async findGulpCommand(rootPath) {
        let gulpCommand;
        const platform = process.platform;
        if (platform === "win32" &&
            (await fs.pathExists(path.join(rootPath, "node_modules", ".bin", "gulp.cmd")))) {
            gulpCommand = path.join(".", "node_modules", ".bin", "gulp.cmd");
        }
        else if ((platform === "linux" || platform === "darwin") &&
            (await fs.pathExists(path.join(rootPath, "node_modules", ".bin", "gulp")))) {
            gulpCommand = path.join(".", "node_modules", ".bin", "gulp");
        }
        else {
            gulpCommand = "gulp";
        }
        return gulpCommand;
    }
}
exports.SPFxPluginImpl = SPFxPluginImpl;
//# sourceMappingURL=plugin.js.map