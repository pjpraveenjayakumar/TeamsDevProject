"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAction = exports.getHostingParentComponent = exports.getComponent = exports.executeFunctionAction = exports.validateQuestion = exports.ValidationError = exports.executeAction = exports.planAction = exports.showSummary = exports.showPlanAndConfirm = exports.ActionNotExist = exports.askQuestionForAction = exports.resolveAction = exports.getEmbeddedValueByPath = exports.getAction = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const Handlebars = tslib_1.__importStar(require("handlebars"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const toposort_1 = tslib_1.__importDefault(require("toposort"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const localizeUtils_1 = require("../common/localizeUtils");
const utils_2 = require("../common/utils");
async function getAction(name, context, inputs) {
    const arr = name.split(".");
    const resourceName = arr[0];
    const actionName = arr[1];
    if (!resourceName)
        throw new Error(`invalid action name: ${name}`);
    try {
        const resource = typedi_1.Container.get(resourceName);
        if (resource[actionName]) {
            const res = await resource[actionName](context, inputs);
            if (res.isOk()) {
                const action = res.value;
                return action;
            }
        }
    }
    catch (e) { }
    return undefined;
}
exports.getAction = getAction;
function _resolveVariables(schema) {
    const variables = new Set();
    extractVariables(schema, variables);
    const graph = [];
    for (const variable of variables) {
        const variableValue = getEmbeddedValueByPath(schema, variable);
        const dependentVariables = extractVariablesInString(variableValue); // variables's dependent variables
        if (dependentVariables.size > 0) {
            for (const dependency of dependentVariables) {
                graph.push([variable, dependency]);
            }
        }
    }
    const list = toposort_1.default(graph).reverse();
    for (let i = 1; i < list.length; ++i) {
        const variable = list[i];
        const variableValue = getEmbeddedValueByPath(schema, variable);
        const replacedValue = _replaceVariables(variableValue, schema);
        setValueByPath(schema, variable, replacedValue);
    }
    _replaceVariables(schema, schema);
}
function _replaceVariables(schema, context) {
    if (typeof schema === "string") {
        const schemaStr = schema;
        if (schemaStr.includes("{{") && schemaStr.includes("}}")) {
            const template = Handlebars.compile(schema);
            const newValue = template(context);
            return newValue;
        }
        return schemaStr;
    }
    else if (typeof schema === "object") {
        for (const key of Object.keys(schema)) {
            const subSchema = schema[key];
            schema[key] = _replaceVariables(subSchema, context);
        }
        return schema;
    }
    else {
        return schema;
    }
}
function extractVariables(obj, set) {
    if (!obj)
        return;
    if (typeof obj === "string") {
        const subSet = extractVariablesInString(obj);
        subSet.forEach((v) => set.add(v));
    }
    else if (typeof obj === "object") {
        for (const key of Object.keys(obj)) {
            const value = obj[key];
            extractVariables(value, set);
        }
    }
}
function extractVariablesInString(schema) {
    if (!schema)
        return new Set();
    let end = 0;
    let start = schema.indexOf("{{");
    let name;
    const set = new Set();
    while (start >= 0) {
        end = schema.indexOf("}}", start + 2);
        name = schema.substring(start + 2, end).trim();
        if (name) {
            set.add(name);
        }
        start = schema.indexOf("{{", end + 2);
    }
    return set;
}
function getEmbeddedValueByPath(obj, path) {
    const array = path.split(".");
    let subObj = obj;
    for (let i = 0; i < array.length; ++i) {
        const key = array[i];
        subObj = subObj[key];
        if (!subObj)
            return undefined;
        if (i < array.length - 1 && typeof subObj !== "object")
            return undefined;
    }
    return subObj;
}
exports.getEmbeddedValueByPath = getEmbeddedValueByPath;
function setValueByPath(obj, path, value) {
    const array = path.split(".");
    const mergeObj = {};
    let subObj = mergeObj;
    for (let i = 0; i < array.length - 1; ++i) {
        const key = array[i];
        subObj[key] = {};
        subObj = subObj[key];
    }
    subObj[array[array.length - 1]] = value;
    lodash_1.merge(obj, mergeObj);
}
function resolveVariables(params, schema) {
    lodash_1.merge(params, schema);
    _resolveVariables(params);
}
async function resolveAction(action, context, inputs) {
    if (action.type === "call") {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        const targetAction = await getAction(action.targetAction, context, inputs);
        if (targetAction) {
            if (targetAction.type !== "function") {
                const resolvedAction = await resolveAction(targetAction, context, inputs);
                if (action.inputs) {
                    resolvedAction["inputs"] = action.inputs;
                }
                return resolvedAction;
            }
        }
        return action;
    }
    else if (action.type === "group") {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        for (let i = 0; i < action.actions.length; ++i) {
            action.actions[i] = await resolveAction(action.actions[i], context, inputs);
        }
    }
    return action;
}
exports.resolveAction = resolveAction;
async function askQuestionForAction(action, context, inputs) {
    if (action.type === "function") {
        // ask question before plan
        if (action.question) {
            const getQuestionRes = await action.question(context, inputs);
            if (getQuestionRes.isErr())
                return teamsfx_api_1.err(getQuestionRes.error);
            const node = getQuestionRes.value;
            if (node) {
                const questionRes = await teamsfx_api_1.traverse(node, inputs, context.userInteraction, context.telemetryReporter);
                if (questionRes.isErr())
                    return teamsfx_api_1.err(questionRes.error);
            }
        }
    }
    else if (action.type === "shell") {
        //TODO
        context.logProvider.info(`---- plan [${inputs.step++}]: shell command: ${action.description}`);
    }
    else if (action.type === "call") {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        const targetAction = await getAction(action.targetAction, context, inputs);
        if (action.required && !targetAction) {
            return teamsfx_api_1.err(new ActionNotExist(action.targetAction));
        }
        if (targetAction) {
            return await askQuestionForAction(targetAction, context, inputs);
        }
    }
    else {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        for (const act of action.actions) {
            const res = await askQuestionForAction(act, context, inputs);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.askQuestionForAction = askQuestionForAction;
class ActionNotExist extends teamsfx_api_1.SystemError {
    constructor(action) {
        super({
            source: "fx",
            message: localizeUtils_1.getDefaultString("error.ActionNotExist", action),
            displayMessage: localizeUtils_1.getLocalizedString("error.ActionNotExist", action),
        });
    }
}
exports.ActionNotExist = ActionNotExist;
async function showPlanAndConfirm(title, effects, context, inputs) {
    let plans = [];
    for (const effect of effects) {
        if (typeof effect === "string") {
            plans.push(effect);
        }
        else if (effect.type === "file") {
            plans = plans.concat(utils_1.fileEffectPlanStrings(effect));
        }
        else if (effect.type === "service") {
            plans.push(utils_1.serviceEffectPlanString(effect));
        }
        else if (effect.type === "bicep") {
            plans = plans.concat(await utils_1.persistBicepPlans(inputs.projectPath, effect));
        }
        else if (effect.type === "shell") {
            plans.push(`shell command: ${effect.description}`);
        }
    }
    for (let i = 0; i < plans.length; ++i) {
        plans[i] = `step ${i + 1} - ${plans[i]}`;
    }
    const res = await context.userInteraction.showMessage("info", title + "\n" + plans.join("\n"), true, "Confirm");
    if (res.isOk() && res.value === "Confirm") {
        return true;
    }
    return false;
}
exports.showPlanAndConfirm = showPlanAndConfirm;
async function showSummary(title, effects, context, inputs) {
    let plans = [];
    for (const effect of effects) {
        if (typeof effect === "string") {
            plans.push(effect);
        }
        else if (effect.type === "file") {
            plans = plans.concat(utils_1.fileEffectPlanStrings(effect));
        }
        else if (effect.type === "service") {
            plans.push(utils_1.serviceEffectPlanString(effect));
        }
        else if (effect.type === "bicep") {
            plans = plans.concat(await utils_1.persistBicepPlans(inputs.projectPath, effect));
        }
        else if (effect.type === "shell") {
            plans.push(`shell command: ${effect.description}`);
        }
    }
    context.logProvider.info(title);
    plans.forEach((p) => context.logProvider.info(p));
}
exports.showSummary = showSummary;
async function planAction(action, context, inputs, effects) {
    if (action.type === "function") {
        if (action.plan) {
            const planRes = await action.plan(context, inputs);
            if (planRes.isErr())
                return teamsfx_api_1.err(planRes.error);
            planRes.value.forEach((e) => effects.push(e));
        }
    }
    else if (action.type === "shell") {
        effects.push(action);
    }
    else if (action.type === "call") {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        const targetAction = await getAction(action.targetAction, context, inputs);
        if (action.required && !targetAction) {
            return teamsfx_api_1.err(new ActionNotExist(action.targetAction));
        }
        if (targetAction) {
            await planAction(targetAction, context, inputs, effects);
        }
    }
    else {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        for (const act of action.actions) {
            const res = await planAction(act, context, inputs, effects);
            if (res.isErr())
                return teamsfx_api_1.err(res.error);
        }
    }
    return teamsfx_api_1.ok(undefined);
}
exports.planAction = planAction;
async function executeAction(action, context, inputs, effects) {
    console.log(`executeAction: ${action.name}`);
    if (action.type === "function") {
        return await executeFunctionAction(action, context, inputs, effects);
    }
    else if (action.type === "shell") {
        effects.push(`shell executed: ${action.command}`);
        return teamsfx_api_1.ok(undefined);
    }
    else if (action.type === "call") {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        const targetAction = await getAction(action.targetAction, context, inputs);
        if (action.required && !targetAction) {
            return teamsfx_api_1.err(new ActionNotExist(action.targetAction));
        }
        if (targetAction) {
            return await executeAction(targetAction, context, inputs, effects);
        }
        return teamsfx_api_1.ok(undefined);
    }
    else {
        if (action.inputs) {
            resolveVariables(inputs, action.inputs);
        }
        if (action.mode === "parallel") {
            const promises = action.actions.map((a) => executeAction(a, context, inputs, effects));
            const results = await Promise.all(promises);
            for (const result of results) {
                if (result.isErr())
                    return teamsfx_api_1.err(result.error);
            }
        }
        else {
            for (const act of action.actions) {
                const res = await executeAction(act, context, inputs, effects);
                if (res.isErr())
                    return teamsfx_api_1.err(res.error);
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
}
exports.executeAction = executeAction;
class ValidationError extends teamsfx_api_1.UserError {
    constructor(msg) {
        super({ message: msg, displayMessage: msg, source: "core" });
    }
}
exports.ValidationError = ValidationError;
async function validateQuestion(question, ui, inputs, step, totalSteps) {
    const validationFunc = question.validation
        ? teamsfx_api_1.getValidationFunction(question.validation, inputs)
        : undefined;
    const answer = getEmbeddedValueByPath(inputs, question.name);
    if (validationFunc) {
        if (!answer)
            return teamsfx_api_1.err(new ValidationError(`question ${question.name} has no answer!`));
        let res = await validationFunc(answer);
        if (res) {
            res = `${question.name}: ${res}`;
            return teamsfx_api_1.err(new ValidationError(res));
        }
    }
    return teamsfx_api_1.ok({ type: "success", result: answer });
}
exports.validateQuestion = validateQuestion;
async function executeFunctionAction(action, context, inputs, effects) {
    context.logProvider.info(`executeFunctionAction [${action.name}] start!`);
    // validate inputs
    if (action.question) {
        const getQuestionRes = await action.question(context, inputs);
        if (getQuestionRes.isErr())
            return teamsfx_api_1.err(getQuestionRes.error);
        const node = getQuestionRes.value;
        if (node) {
            const validationRes = await teamsfx_api_1.traverse(node, inputs, context.userInteraction, context.telemetryReporter, validateQuestion);
            if (validationRes.isErr())
                teamsfx_api_1.err(validationRes.error);
        }
    }
    const res = await action.execute(context, inputs);
    if (res.isErr())
        return teamsfx_api_1.err(res.error);
    if (res.value) {
        //persist bicep files for bicep effects
        for (const effect of res.value) {
            if (typeof effect !== "string" && effect.type === "bicep") {
                const bicep = effect;
                if (bicep) {
                    const bicepPlans = await utils_1.persistBicepPlans(inputs.projectPath, bicep);
                    bicepPlans.forEach((p) => effects.push(p));
                    // TODO: handle the returned error of bicep generation
                    await utils_1.persistBicep(inputs.projectPath, utils_2.convertToAlphanumericOnly(context.projectSetting.appName), bicep);
                }
            }
            else {
                effects.push(effect);
            }
        }
    }
    context.logProvider.info(`executeFunctionAction [${action.name}] finish!`);
    return teamsfx_api_1.ok(undefined);
}
exports.executeFunctionAction = executeFunctionAction;
function getComponent(projectSettings, resourceType) {
    var _a;
    return (_a = projectSettings.components) === null || _a === void 0 ? void 0 : _a.find((r) => r.name === resourceType);
}
exports.getComponent = getComponent;
function getHostingParentComponent(projectSettings, resourceType) {
    var _a;
    const hostingComponent = getComponent(projectSettings, resourceType);
    const parentName = (_a = hostingComponent === null || hostingComponent === void 0 ? void 0 : hostingComponent.connections) === null || _a === void 0 ? void 0 : _a.find((name) => {
        const component = getComponent(projectSettings, name);
        return (component === null || component === void 0 ? void 0 : component.hosting) === hostingComponent.name;
    });
    if (!parentName) {
        return undefined;
    }
    const parent = getComponent(projectSettings, parentName);
    return parent;
}
exports.getHostingParentComponent = getHostingParentComponent;
async function runAction(actionName, context, inputs) {
    context.logProvider.info(`------------------------run action: ${actionName} start!------------------------`);
    const action = await getAction(actionName, context, inputs);
    if (action) {
        const questionRes = await askQuestionForAction(action, context, inputs);
        if (questionRes.isErr())
            return teamsfx_api_1.err(questionRes.error);
        const planEffects = [];
        await planAction(action, context, lodash_1.cloneDeep(inputs), planEffects);
        // const confirm = await showPlanAndConfirm(
        //   `action: ${actionName} will do the following changes:`,
        //   planEffects,
        //   context,
        //   inputs
        // );
        // if (confirm) {
        const execEffects = [];
        const execRes = await executeAction(action, context, inputs, execEffects);
        if (execRes.isErr())
            return execRes;
        await showSummary(`${actionName} summary:`, execEffects, context, inputs);
        // }
    }
    else {
        return teamsfx_api_1.err(new teamsfx_api_1.SystemError({
            source: "fx",
            name: "ActionNotFoundError",
            message: "action not found:" + actionName,
        }));
    }
    context.logProvider.info(`------------------------run action: ${actionName} finish!------------------------`);
    return teamsfx_api_1.ok(undefined);
}
exports.runAction = runAction;
//# sourceMappingURL=workflow.js.map